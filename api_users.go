/*
Privileged Access Security REST API

Display the PVWA REST APIs below for a description of how to use them and try them out. Access information about additional REST APIs through the online documentation.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package gopas

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"reflect"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// UsersApiService UsersApi service
type UsersApiService service

type ApiUsersActivateUserRequest struct {
	ctx        _context.Context
	ApiService *UsersApiService
	userID     string
}

func (r ApiUsersActivateUserRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersActivateUserExecute(r)
}

/*
UsersActivateUser Method for UsersActivateUser

This method activates an existing Vault user who was suspended after reaching the maximum number of violations.
To run this web service, the user must have the Audit users and Activate Users permissions in the Vault.
To activate a user, the user must be associated with only one network area.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userID The ID of the user to activate.
 @return ApiUsersActivateUserRequest
*/
func (a *UsersApiService) UsersActivateUser(ctx _context.Context, userID string) ApiUsersActivateUserRequest {
	return ApiUsersActivateUserRequest{
		ApiService: a,
		ctx:        ctx,
		userID:     userID,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersActivateUserExecute(r ApiUsersActivateUserRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersActivateUser")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users/{userID}/Activate"
	localVarPath = strings.Replace(localVarPath, "{"+"userID"+"}", _neturl.PathEscape(parameterToString(r.userID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersAddUserSSHKeyRequest struct {
	ctx         _context.Context
	ApiService  *UsersApiService
	userID      string
	sshKeyToAdd *AddUserSSHKeyModel
}

// The ssh key to add to the user
func (r ApiUsersAddUserSSHKeyRequest) SshKeyToAdd(sshKeyToAdd AddUserSSHKeyModel) ApiUsersAddUserSSHKeyRequest {
	r.sshKeyToAdd = &sshKeyToAdd
	return r
}

func (r ApiUsersAddUserSSHKeyRequest) Execute() (PublicSSHKeyModel, *_nethttp.Response, error) {
	return r.ApiService.UsersAddUserSSHKeyExecute(r)
}

/*
UsersAddUserSSHKey Method for UsersAddUserSSHKey

This method adds an ssh public key to the vault for the user id

To run this web service, the user must have the Audit users permissions in the Vault.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userID The ID of the user to add the ssh key to.
 @return ApiUsersAddUserSSHKeyRequest
*/
func (a *UsersApiService) UsersAddUserSSHKey(ctx _context.Context, userID string) ApiUsersAddUserSSHKeyRequest {
	return ApiUsersAddUserSSHKeyRequest{
		ApiService: a,
		ctx:        ctx,
		userID:     userID,
	}
}

// Execute executes the request
//  @return PublicSSHKeyModel
func (a *UsersApiService) UsersAddUserSSHKeyExecute(r ApiUsersAddUserSSHKeyRequest) (PublicSSHKeyModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PublicSSHKeyModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersAddUserSSHKey")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users/{userID}/Secret/SSHKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"userID"+"}", _neturl.PathEscape(parameterToString(r.userID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.sshKeyToAdd == nil {
		return localVarReturnValue, nil, reportError("sshKeyToAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sshKeyToAdd
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersCreateUserRequest struct {
	ctx        _context.Context
	ApiService *UsersApiService
	user       *User
}

func (r ApiUsersCreateUserRequest) User(user User) ApiUsersCreateUserRequest {
	r.user = &user
	return r
}

func (r ApiUsersCreateUserRequest) Execute() (User, *_nethttp.Response, error) {
	return r.ApiService.UsersCreateUserExecute(r)
}

/*
UsersCreateUser Method for UsersCreateUser

This method adds a new user to the Vault.

To run this web service, the user must have the Add/Update Users authorization in the Vault.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersCreateUserRequest
*/
func (a *UsersApiService) UsersCreateUser(ctx _context.Context) ApiUsersCreateUserRequest {
	return ApiUsersCreateUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersCreateUserExecute(r ApiUsersCreateUserRequest) (User, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersCreateUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.user == nil {
		return localVarReturnValue, nil, reportError("user is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.user
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersDeleteUserRequest struct {
	ctx        _context.Context
	ApiService *UsersApiService
	userID     string
}

func (r ApiUsersDeleteUserRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersDeleteUserExecute(r)
}

/*
UsersDeleteUser Method for UsersDeleteUser

This method deletes information about a specific User in the Vault.

To run this web service, the user must have the AddUpdate users permissions in the Vault.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userID The ID of the User to delete.
 @return ApiUsersDeleteUserRequest
*/
func (a *UsersApiService) UsersDeleteUser(ctx _context.Context, userID string) ApiUsersDeleteUserRequest {
	return ApiUsersDeleteUserRequest{
		ApiService: a,
		ctx:        ctx,
		userID:     userID,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersDeleteUserExecute(r ApiUsersDeleteUserRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersDeleteUser")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users/{userID}"
	localVarPath = strings.Replace(localVarPath, "{"+"userID"+"}", _neturl.PathEscape(parameterToString(r.userID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersDeleteUserSSHKeyRequest struct {
	ctx         _context.Context
	ApiService  *UsersApiService
	userID      string
	sshKeyToDel *DeleteUserSSHKeyModel
}

// The SSH Key fingerprint to delete
func (r ApiUsersDeleteUserSSHKeyRequest) SshKeyToDel(sshKeyToDel DeleteUserSSHKeyModel) ApiUsersDeleteUserSSHKeyRequest {
	r.sshKeyToDel = &sshKeyToDel
	return r
}

func (r ApiUsersDeleteUserSSHKeyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersDeleteUserSSHKeyExecute(r)
}

/*
UsersDeleteUserSSHKey Method for UsersDeleteUserSSHKey

This method deletes an ssh public key on the vault for the user id

To run this web service, the user must have the Audit users permissions in the Vault.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userID The ID of the user to delete the public ssh key from.
 @return ApiUsersDeleteUserSSHKeyRequest
*/
func (a *UsersApiService) UsersDeleteUserSSHKey(ctx _context.Context, userID string) ApiUsersDeleteUserSSHKeyRequest {
	return ApiUsersDeleteUserSSHKeyRequest{
		ApiService: a,
		ctx:        ctx,
		userID:     userID,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersDeleteUserSSHKeyExecute(r ApiUsersDeleteUserSSHKeyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersDeleteUserSSHKey")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users/{userID}/Secret/SSHKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"userID"+"}", _neturl.PathEscape(parameterToString(r.userID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.sshKeyToDel == nil {
		return nil, reportError("sshKeyToDel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sshKeyToDel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersDestroyAllUsersCachedSSHKeyRequest struct {
	ctx           _context.Context
	ApiService    *UsersApiService
	search        *string
	userType      *string
	componentUser *bool
}

func (r ApiUsersDestroyAllUsersCachedSSHKeyRequest) Search(search string) ApiUsersDestroyAllUsersCachedSSHKeyRequest {
	r.search = &search
	return r
}

// The type of the user.
func (r ApiUsersDestroyAllUsersCachedSSHKeyRequest) UserType(userType string) ApiUsersDestroyAllUsersCachedSSHKeyRequest {
	r.userType = &userType
	return r
}

// Whether the user is a known component or not.
func (r ApiUsersDestroyAllUsersCachedSSHKeyRequest) ComponentUser(componentUser bool) ApiUsersDestroyAllUsersCachedSSHKeyRequest {
	r.componentUser = &componentUser
	return r
}

func (r ApiUsersDestroyAllUsersCachedSSHKeyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersDestroyAllUsersCachedSSHKeyExecute(r)
}

/*
UsersDestroyAllUsersCachedSSHKey Method for UsersDestroyAllUsersCachedSSHKey

This method deletes all the cached ssh public key for all the users with the given filters

To run this web service, the user must have the Audit users permissions in the Vault.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersDestroyAllUsersCachedSSHKeyRequest
*/
func (a *UsersApiService) UsersDestroyAllUsersCachedSSHKey(ctx _context.Context) ApiUsersDestroyAllUsersCachedSSHKeyRequest {
	return ApiUsersDestroyAllUsersCachedSSHKeyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersDestroyAllUsersCachedSSHKeyExecute(r ApiUsersDestroyAllUsersCachedSSHKeyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersDestroyAllUsersCachedSSHKey")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users/Secret/SSHKeys/ClearCache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.userType != nil {
		localVarQueryParams.Add("userType", parameterToString(*r.userType, ""))
	}
	if r.componentUser != nil {
		localVarQueryParams.Add("componentUser", parameterToString(*r.componentUser, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersDestroyCurrentUserCachedSSHKeyRequest struct {
	ctx        _context.Context
	ApiService *UsersApiService
}

func (r ApiUsersDestroyCurrentUserCachedSSHKeyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersDestroyCurrentUserCachedSSHKeyExecute(r)
}

/*
UsersDestroyCurrentUserCachedSSHKey Method for UsersDestroyCurrentUserCachedSSHKey

This method deletes the cached ssh public key for the logged user from the vault

To run this web service, the user must only be authenticated to the vault

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersDestroyCurrentUserCachedSSHKeyRequest
*/
func (a *UsersApiService) UsersDestroyCurrentUserCachedSSHKey(ctx _context.Context) ApiUsersDestroyCurrentUserCachedSSHKeyRequest {
	return ApiUsersDestroyCurrentUserCachedSSHKeyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersDestroyCurrentUserCachedSSHKeyExecute(r ApiUsersDestroyCurrentUserCachedSSHKeyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersDestroyCurrentUserCachedSSHKey")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users/Secret/SSHKeys/Cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersDestroyUserCachedSSHKeyRequest struct {
	ctx        _context.Context
	ApiService *UsersApiService
	userID     string
}

func (r ApiUsersDestroyUserCachedSSHKeyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersDestroyUserCachedSSHKeyExecute(r)
}

/*
UsersDestroyUserCachedSSHKey Method for UsersDestroyUserCachedSSHKey

This method deletes the cached ssh public key for the given user id from the vault

To run this web service, the user must have the Audit users permissions in the Vault.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userID The ID of the User for which the cached ssh key will be destroyed.
 @return ApiUsersDestroyUserCachedSSHKeyRequest
*/
func (a *UsersApiService) UsersDestroyUserCachedSSHKey(ctx _context.Context, userID string) ApiUsersDestroyUserCachedSSHKeyRequest {
	return ApiUsersDestroyUserCachedSSHKeyRequest{
		ApiService: a,
		ctx:        ctx,
		userID:     userID,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersDestroyUserCachedSSHKeyExecute(r ApiUsersDestroyUserCachedSSHKeyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersDestroyUserCachedSSHKey")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users/{userID}/Secret/SSHKeys/Cache"
	localVarPath = strings.Replace(localVarPath, "{"+"userID"+"}", _neturl.PathEscape(parameterToString(r.userID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersEditUserRequest struct {
	ctx        _context.Context
	ApiService *UsersApiService
	userID     string
	user       *User
}

func (r ApiUsersEditUserRequest) User(user User) ApiUsersEditUserRequest {
	r.user = &user
	return r
}

func (r ApiUsersEditUserRequest) Execute() (User, *_nethttp.Response, error) {
	return r.ApiService.UsersEditUserExecute(r)
}

/*
UsersEditUser Method for UsersEditUser

This method edit an existing user.
To run this web service, the user must have the Add/Update Users authorization in the Vault.
In order to Edit "changePasswordOnTheNextLogon" the user must have the Reset Password authorization in the Vault.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userID The ID of the user to update.
 @return ApiUsersEditUserRequest
*/
func (a *UsersApiService) UsersEditUser(ctx _context.Context, userID string) ApiUsersEditUserRequest {
	return ApiUsersEditUserRequest{
		ApiService: a,
		ctx:        ctx,
		userID:     userID,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersEditUserExecute(r ApiUsersEditUserRequest) (User, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersEditUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users/{userID}"
	localVarPath = strings.Replace(localVarPath, "{"+"userID"+"}", _neturl.PathEscape(parameterToString(r.userID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.user == nil {
		return localVarReturnValue, nil, reportError("user is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.user
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGenerateCurrentUserCachedSSHKeyRequest struct {
	ctx        _context.Context
	ApiService *UsersApiService
	genModel   *GenerateUserCachedSSHKeyModel
}

// The information as to how to format and output the generated ssh key
func (r ApiUsersGenerateCurrentUserCachedSSHKeyRequest) GenModel(genModel GenerateUserCachedSSHKeyModel) ApiUsersGenerateCurrentUserCachedSSHKeyRequest {
	r.genModel = &genModel
	return r
}

func (r ApiUsersGenerateCurrentUserCachedSSHKeyRequest) Execute() (GenerateUserCachedSSHKeyResponse, *_nethttp.Response, error) {
	return r.ApiService.UsersGenerateCurrentUserCachedSSHKeyExecute(r)
}

/*
UsersGenerateCurrentUserCachedSSHKey Method for UsersGenerateCurrentUserCachedSSHKey

This method generates a cached ssh public key for the logged user and stores it on the vault

To run this web service, the user must only be authenticated to the vault

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersGenerateCurrentUserCachedSSHKeyRequest
*/
func (a *UsersApiService) UsersGenerateCurrentUserCachedSSHKey(ctx _context.Context) ApiUsersGenerateCurrentUserCachedSSHKeyRequest {
	return ApiUsersGenerateCurrentUserCachedSSHKeyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return GenerateUserCachedSSHKeyResponse
func (a *UsersApiService) UsersGenerateCurrentUserCachedSSHKeyExecute(r ApiUsersGenerateCurrentUserCachedSSHKeyRequest) (GenerateUserCachedSSHKeyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GenerateUserCachedSSHKeyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGenerateCurrentUserCachedSSHKey")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users/Secret/SSHKeys/Cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.genModel == nil {
		return localVarReturnValue, nil, reportError("genModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.genModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGenerateUserCachedSSHKeyRequest struct {
	ctx        _context.Context
	ApiService *UsersApiService
	userID     string
	genModel   *GenerateUserCachedSSHKeyModel
}

// The information as to how to format and output the generated ssh key
func (r ApiUsersGenerateUserCachedSSHKeyRequest) GenModel(genModel GenerateUserCachedSSHKeyModel) ApiUsersGenerateUserCachedSSHKeyRequest {
	r.genModel = &genModel
	return r
}

func (r ApiUsersGenerateUserCachedSSHKeyRequest) Execute() (GenerateUserCachedSSHKeyResponse, *_nethttp.Response, error) {
	return r.ApiService.UsersGenerateUserCachedSSHKeyExecute(r)
}

/*
UsersGenerateUserCachedSSHKey Method for UsersGenerateUserCachedSSHKey

This method generates a cached ssh public key a given user and stores it on the vault

To run this web service, the user must have the Audit users permissions in the Vault.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userID The ID of the User for which the key will be generated
 @return ApiUsersGenerateUserCachedSSHKeyRequest
*/
func (a *UsersApiService) UsersGenerateUserCachedSSHKey(ctx _context.Context, userID string) ApiUsersGenerateUserCachedSSHKeyRequest {
	return ApiUsersGenerateUserCachedSSHKeyRequest{
		ApiService: a,
		ctx:        ctx,
		userID:     userID,
	}
}

// Execute executes the request
//  @return GenerateUserCachedSSHKeyResponse
func (a *UsersApiService) UsersGenerateUserCachedSSHKeyExecute(r ApiUsersGenerateUserCachedSSHKeyRequest) (GenerateUserCachedSSHKeyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GenerateUserCachedSSHKeyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGenerateUserCachedSSHKey")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users/{userID}/Secret/SSHKeys/Cache"
	localVarPath = strings.Replace(localVarPath, "{"+"userID"+"}", _neturl.PathEscape(parameterToString(r.userID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.genModel == nil {
		return localVarReturnValue, nil, reportError("genModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.genModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGetUserDetailsRequest struct {
	ctx        _context.Context
	ApiService *UsersApiService
	userID     string
}

func (r ApiUsersGetUserDetailsRequest) Execute() (User, *_nethttp.Response, error) {
	return r.ApiService.UsersGetUserDetailsExecute(r)
}

/*
UsersGetUserDetails Method for UsersGetUserDetails

This method returns information about a specific User in the Vault.

To run this web service, the user must have the Audit users permissions in the Vault.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userID The ID of the User for which information is returned.
 @return ApiUsersGetUserDetailsRequest
*/
func (a *UsersApiService) UsersGetUserDetails(ctx _context.Context, userID string) ApiUsersGetUserDetailsRequest {
	return ApiUsersGetUserDetailsRequest{
		ApiService: a,
		ctx:        ctx,
		userID:     userID,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersGetUserDetailsExecute(r ApiUsersGetUserDetailsRequest) (User, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGetUserDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users/{userID}"
	localVarPath = strings.Replace(localVarPath, "{"+"userID"+"}", _neturl.PathEscape(parameterToString(r.userID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGetUserSSHKeysRequest struct {
	ctx                _context.Context
	ApiService         *UsersApiService
	userID             string
	keyStoreTypeFilter *int32
}

// The key type filter
func (r ApiUsersGetUserSSHKeysRequest) KeyStoreTypeFilter(keyStoreTypeFilter int32) ApiUsersGetUserSSHKeysRequest {
	r.keyStoreTypeFilter = &keyStoreTypeFilter
	return r
}

func (r ApiUsersGetUserSSHKeysRequest) Execute() (GetUserSSHKeysResponse, *_nethttp.Response, error) {
	return r.ApiService.UsersGetUserSSHKeysExecute(r)
}

/*
UsersGetUserSSHKeys Method for UsersGetUserSSHKeys

This method gets the ssh public keys stored in the vault for the user

To run this web service, the user must have reset users password permissions.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userID The ID of the user for which public ssh keys are returned.
 @return ApiUsersGetUserSSHKeysRequest
*/
func (a *UsersApiService) UsersGetUserSSHKeys(ctx _context.Context, userID string) ApiUsersGetUserSSHKeysRequest {
	return ApiUsersGetUserSSHKeysRequest{
		ApiService: a,
		ctx:        ctx,
		userID:     userID,
	}
}

// Execute executes the request
//  @return GetUserSSHKeysResponse
func (a *UsersApiService) UsersGetUserSSHKeysExecute(r ApiUsersGetUserSSHKeysRequest) (GetUserSSHKeysResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GetUserSSHKeysResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGetUserSSHKeys")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users/{userID}/Secret/SSHKeys"
	localVarPath = strings.Replace(localVarPath, "{"+"userID"+"}", _neturl.PathEscape(parameterToString(r.userID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.keyStoreTypeFilter != nil {
		localVarQueryParams.Add("keyStoreTypeFilter", parameterToString(*r.keyStoreTypeFilter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGetUsersRequest struct {
	ctx             _context.Context
	ApiService      *UsersApiService
	extendedDetails *bool
	search          *string
	sort            *[]string
	userName        *string
	userType        *string
	componentUser   *bool
}

// returns users group membership if true
func (r ApiUsersGetUsersRequest) ExtendedDetails(extendedDetails bool) ApiUsersGetUsersRequest {
	r.extendedDetails = &extendedDetails
	return r
}
func (r ApiUsersGetUsersRequest) Search(search string) ApiUsersGetUsersRequest {
	r.search = &search
	return r
}
func (r ApiUsersGetUsersRequest) Sort(sort []string) ApiUsersGetUsersRequest {
	r.sort = &sort
	return r
}

// The name of the user.
func (r ApiUsersGetUsersRequest) UserName(userName string) ApiUsersGetUsersRequest {
	r.userName = &userName
	return r
}

// The type of the user.
func (r ApiUsersGetUsersRequest) UserType(userType string) ApiUsersGetUsersRequest {
	r.userType = &userType
	return r
}

// Whether the user is a known component or not.
func (r ApiUsersGetUsersRequest) ComponentUser(componentUser bool) ApiUsersGetUsersRequest {
	r.componentUser = &componentUser
	return r
}

func (r ApiUsersGetUsersRequest) Execute() ([]BaseUser, *_nethttp.Response, error) {
	return r.ApiService.UsersGetUsersExecute(r)
}

/*
UsersGetUsers Method for UsersGetUsers

This method will return a list of all existing users in the Vault except of the Master and the Batch built-in users.

To run this web service, the user must have the Audit users permissions in the Vault.

The user who runs this web service can see users only on the same location or lower in the Vault hierarchy.

The HideVaultUsersTree  parameter in the dbparam.ini determines the users that are displayed.If HideVaultUsersTree is set to No, all users will be returned (not only those in the same level or lower in the Vault hierarchy). If this parameter is set to Yes, only auditors and managers will be allowed to get all users.

Note: We currently support returning up to X users in up to Y minutes. If the amount of users is above that number, the REST request might take longer

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersGetUsersRequest
*/
func (a *UsersApiService) UsersGetUsers(ctx _context.Context) ApiUsersGetUsersRequest {
	return ApiUsersGetUsersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BaseUser
func (a *UsersApiService) UsersGetUsersExecute(r ApiUsersGetUsersRequest) ([]BaseUser, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BaseUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGetUsers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.extendedDetails != nil {
		localVarQueryParams.Add("ExtendedDetails", parameterToString(*r.extendedDetails, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	if r.userName != nil {
		localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	}
	if r.userType != nil {
		localVarQueryParams.Add("userType", parameterToString(*r.userType, ""))
	}
	if r.componentUser != nil {
		localVarQueryParams.Add("componentUser", parameterToString(*r.componentUser, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersResetUserPasswordRequest struct {
	ctx               _context.Context
	ApiService        *UsersApiService
	userID            string
	resetUserPassword *ResetUserPassword
}

func (r ApiUsersResetUserPasswordRequest) ResetUserPassword(resetUserPassword ResetUserPassword) ApiUsersResetUserPasswordRequest {
	r.resetUserPassword = &resetUserPassword
	return r
}

func (r ApiUsersResetUserPasswordRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UsersResetUserPasswordExecute(r)
}

/*
UsersResetUserPassword Method for UsersResetUserPassword

This method resets an existing Vault user's password.
To run this web service, the user must have the Audit users and Reset Users' Passwords permissions in the Vault.
In addition, the user who runs this web service must be in the same Vault Location or higher as the user whose password is being reset.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userID The ID of the user whose password will be reset.
 @return ApiUsersResetUserPasswordRequest
*/
func (a *UsersApiService) UsersResetUserPassword(ctx _context.Context, userID string) ApiUsersResetUserPasswordRequest {
	return ApiUsersResetUserPasswordRequest{
		ApiService: a,
		ctx:        ctx,
		userID:     userID,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersResetUserPasswordExecute(r ApiUsersResetUserPasswordRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersResetUserPassword")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Users/{userID}/ResetPassword"
	localVarPath = strings.Replace(localVarPath, "{"+"userID"+"}", _neturl.PathEscape(parameterToString(r.userID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.resetUserPassword == nil {
		return nil, reportError("resetUserPassword is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resetUserPassword
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
